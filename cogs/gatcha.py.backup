import discord
import random
import asyncio
import time
import config
from discord.ext import commands
from discord.ui import View, Button, button
from utils.database import load, save
from utils.game_math import regenerate_pulls


def has_patreon_role(member):
    """Check if member has any patreon role or is marked as a patron in the database"""
    if not member:
        return False

    try:
        # First check database
        users = load(USERS_FILE)
        uid = str(member.id)
        if uid in users and "patreon" in users[uid]:
            # Check if the subscription is still valid
            if users[uid]["patreon"].get("expires_at", 0) > time.time():
                return True

        # Then check roles
        if hasattr(member, 'roles'):
            member_role_ids = [role.id for role in member.roles]
            return any(role_id in config.PATREON_ROLES for role_id in member_role_ids)

        return False
    except Exception as e:
        print(f"Error checking patreon status for {member}: {e}")
        return False


USERS_FILE = "data/users.json"
CARDS_FILE = "data/cards.json"
RARITIES_FILE = "data/rarities.json"
BOSSES_FILE = "data/bosses.json"
EMOJI_FILE = "data/emoji.json"


class PullAgainView(View):
    """(Deprecated) Previously used for a 'Pull Again' button. Kept for compatibility but no longer used."""

    def __init__(self, ctx):
        super().__init__(timeout=120)
        self.ctx = ctx


class Gacha(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    def ensure_user(self, users, uid):
        """Ensure user exists in database"""
        if uid not in users:
            users[uid] = {
                "pulls": config.MAX_PULLS,
                "max_pulls": config.MAX_PULLS,  # Default max_pulls
                "yen": 0,
                "cards": [],
                "fragments": {},
                "unlocked": [],
                "chests": {},
                "tickets": {},
                "equipment": {},
                "wins": 0,
                "streak": 0,
                "last_pull_regen_ts": int(time.time())
            }
        else:
            # Ensure max_pulls is at least config.MAX_PULLS
            users[uid]["max_pulls"] = max(users[uid].get(
                "max_pulls", config.MAX_PULLS), config.MAX_PULLS)
            # Ensure pulls doesn't exceed max_pulls
            users[uid]["pulls"] = min(users[uid].get(
                "pulls", config.MAX_PULLS), users[uid]["max_pulls"])
            # Ensure last_pull_regen_ts exists
            if "last_pull_regen_ts" not in users[uid]:
                users[uid]["last_pull_regen_ts"] = int(time.time())
        return users[uid]

    def get_card_type(self, stats):
        """Determine card type based on stats"""
        attack = stats.get('attack', 0)
        health = stats.get('health', 0)
        speed = stats.get('speed', 0)

        if health == 0:
            return "Unknown"

        # Tank: health is speed + 70% attack
        if health >= (speed + (attack * 0.7)):
            return "Tank"
        # Balanced: health is between 50% and 70% of (speed + attack)
        elif health >= (speed + attack) * 0.5:
            return "Balanced"
        # Speedster: health is less than 50% of (speed + attack)
        else:
            # Speedster: speed is 65% of health
            if speed >= (health * 0.65):
                return "Speedster"
            # Striker: attack is 50% of health
            elif attack >= (health * 0.5):
                return "Striker"
            # Prodigy: speed = attack (within 10% tolerance)
            elif abs(speed - attack) <= (max(speed, attack) * 0.1):
                return "Prodigy"
            # Default to Balanced if none match
            else:
                return "Balanced"

    @commands.command(name="pull")
    async def pull(self, ctx):
        """Summon a character! Usage: ls pull"""
        users = load(USERS_FILE)
        uid = str(ctx.author.id)
        user = self.ensure_user(users, uid)

        # Ensure max_pulls is set
        if "max_pulls" not in user:
            user["max_pulls"] = config.MAX_PULLS

        # Regenerate pulls before checking
        user = regenerate_pulls(user)

        # Ensure pulls don't exceed max_pulls
        max_pulls = user["max_pulls"]
        if user.get("pulls", 0) > max_pulls:
            user["pulls"] = max_pulls
            user["last_pull_regen_ts"] = int(time.time())

        # Save updated user
        users[uid] = user
        save(USERS_FILE, users)

        current_pulls = user.get("pulls", 0)
        if current_pulls <= 0:
            embed = discord.Embed(
                title="âŒ Out of Pulls!",
                description=f"You have `0/{max_pulls}` pulls left.\n\nUse `ls cd` to check cooldowns.\nOr use `ls resetpulls` to reset pulls with a reset token!",
                color=0xE74C3C
            )
            embed.set_author(name=ctx.author.display_name,
                          icon_url=ctx.author.display_avatar.url)
            return await ctx.send(embed=embed)

        # --- ANIMATION (1-2 seconds) ---
        embed = discord.Embed(
            title="âœ¨ Summoning Character...",
            description="The summoning orb is glowing...",
            color=0x5865F2
        )
        embed.set_author(name=ctx.author.display_name,
                       icon_url=ctx.author.display_avatar.url)
        embed.set_image(url=config.IMG_SUMMON_ORB)
        embed.set_footer(text="Summoning in progress...")
        msg = await ctx.send(embed=embed)

        # Random between 1-2 seconds
        await asyncio.sleep(random.uniform(1.0, 2.0))

        # --- LOGIC ---
        user["pulls"] -= 1

        # 1. Ticket Logic (2.5% Chance)
        ticket_drop = None
        try:
            bosses = load(BOSSES_FILE)
            if bosses and random.random() * 100 <= 2.5:
                # Weighted choice
                total = sum(b.get('ticket_drop_rate', 0)
                            for b in bosses.values())
                if total > 0:
                    r = random.uniform(0, total)
                    curr = 0
                    for b in bosses.values():
                        curr += b.get('ticket_drop_rate', 0)
                        if r <= curr:
                            ticket_drop = b
                            break

            if ticket_drop:
                user.setdefault("tickets", {})
                tid = f"{ticket_drop.get('name', '').lower().replace(' ', '_')}_ticket"
                user["tickets"][tid] = user["tickets"].get(tid, 0) + 1
        except Exception as e:
            print(f"Error loading bosses: {e}")

        # 2. Card Logic - Load from dictionary structure
        cards_dict = load(CARDS_FILE)
        rarities = load(RARITIES_FILE)

        if not cards_dict:
            embed = discord.Embed(
                title="âŒ No Cards Available",
                description="Card database is empty! Please add cards first.",
                color=0xE74C3C
            )
            await msg.edit(embed=embed)
            return

        # Convert dict to list for weighted selection
        cards_list = list(cards_dict.values())

        # Calculate weights based on rarity
        weights = []
        for card in cards_list:
            rarity_key = card.get('rarity', 'C')
            rarity_info = rarities.get(rarity_key, {})
            # Default to 5 if not found
            weight = rarity_info.get('weight_multiplier', 5)
            weights.append(weight)

        # Select card
        chosen = random.choices(cards_list, weights=weights, k=1)[0]
        chosen_rarity = chosen.get('rarity', 'C')
        rarity_info = rarities.get(chosen_rarity, {})

        user.setdefault("cards", [])
        user.setdefault("unlocked", [])
        is_new = False
        card_name = chosen.get('name', 'Unknown')

        if card_name not in user.get("unlocked", []):
            is_new = True
            user.setdefault("unlocked", []).append(card_name)
            user["cards"].append({
                "name": card_name,
                "rarity": chosen_rarity,
                "level": 1,
                "exp": 0,
                "evo": 0,
                "aura": 0
            })
        else:
            user.setdefault("fragments", {})
            user["fragments"][card_name] = user["fragments"].get(
                card_name, 0) + 1

        # Save user data
        users[uid] = user
        save(USERS_FILE, users)

        # --- RESULT EMBED ---
        try:
            # Get rarity color
            rarity_color = rarity_info.get("color", "#5865F2")
            col = int(rarity_color.replace("#", ""), 16)
        except:
            col = 0x5865F2

        # Get rarity display name and emoji
        rarity_display = rarity_info.get("display_name", chosen_rarity)
        rarity_emoji = rarity_info.get("emoji", "â­")

        # Build title with rarity emoji
        title = f"{rarity_emoji} {card_name}"

        # Build description
        status_text = "âœ¨ **NEW CHARACTER!**" if is_new else "ğŸ’ **Converted to Shards**"
        description = f"**{rarity_display}** ({chosen_rarity})\n{status_text}"

        final_embed = discord.Embed(
            title=title,
            description=description,
            color=col
        )
        final_embed.set_author(
            name=ctx.author.display_name, icon_url=ctx.author.display_avatar.url)

        # Set rarity icon as thumbnail
        if rarity_info.get("icon"):
            final_embed.set_thumbnail(url=rarity_info["icon"])

        # Set card image (evo_1) as main image
        card_images = chosen.get("images", {})
        if card_images.get("evo_1"):
            final_embed.set_image(url=card_images["evo_1"])

        # Add stats preview if available (WITHOUT EMOJIS, using names)
        card_stats = chosen.get("stats", {})
        if card_stats.get("evo_1"):
            stats = card_stats["evo_1"]
            attack = stats.get('attack', 'N/A')
            health = stats.get('health', 'N/A')
            speed = stats.get('speed', 'N/A')

            # Determine card type
            card_type = self.get_card_type(stats)

            stats_text = f"**Strength:** `{attack}`\n**Health:** `{health}`\n**Speed:** `{speed}`"
            final_embed.add_field(
                name="ğŸ“Š Base Stats (Evo 1)", value=stats_text, inline=False)
            final_embed.add_field(
                name="ğŸ¯ Type", value=f"**{card_type}**", inline=True)

        # Add ability if available
        if chosen.get("ability") and chosen.get("ability") != "None":
            final_embed.add_field(
                name="âœ¨ Ability", value=chosen.get("ability"), inline=False)

        # Footer with info
        max_pulls = user.get("max_pulls", config.MAX_PULLS)
        footer_parts = [f"Pulls: {user['pulls']}/{max_pulls}"]

        if ticket_drop:
            footer_parts.append(
                f"BONUS: {ticket_drop.get('name', 'Unknown')} Ticket!")

        if not is_new:
            frag_count = user["fragments"].get(card_name, 0)
            footer_parts.append(f"Shards: {frag_count}")

        final_embed.set_footer(text=" â€¢ ".join(footer_parts))

        # Clean UI: no extra buttons, just show the result
        await msg.edit(embed=final_embed, view=None)

    @commands.command(name="mp", aliases=["mass_pull", "masspull"])
    async def mass_pull(self, ctx):
        """Mass pull all remaining pulls at once (Patreon only)! Usage: ls mp"""
        # Check patreon role - get member from guild if available
        member = ctx.guild.get_member(
            ctx.author.id) if ctx.guild else ctx.author
        if not has_patreon_role(member):
            embed = discord.Embed(
                title="âŒ Patreon Only",
                description="This command is only available to **Patreon members**!\n\nSupport us on Patreon to unlock this feature!",
                color=0xE74C3C,
            )
            embed.set_author(
                name=ctx.author.display_name,
                icon_url=ctx.author.display_avatar.url,
            )
            return await ctx.send(embed=embed)

        # Load and regenerate pulls
        users = load(USERS_FILE)
        uid = str(ctx.author.id)
        user = self.ensure_user(users, uid)
        user = regenerate_pulls(user)

        # Save updated user
        users[uid] = user
        save(USERS_FILE, users)

        amount = user.get("pulls", 0)
        if amount <= 0:
            max_pulls = user.get("max_pulls", config.MAX_PULLS)
            embed = discord.Embed(
                title="âŒ Out of Pulls!",
                description=(
                    f"You have `{user.get('pulls', 0)}/{max_pulls}` pulls left. "
                    "Nothing to mass pull.\n\nUse `ls cd` to check cooldowns."
                ),
                color=0xE74C3C,
            )
            embed.set_author(
                name=ctx.author.display_name,
                icon_url=ctx.author.display_avatar.url,
            )
            return await ctx.send(embed=embed)

        # Start mass pull (use all remaining pulls)
        loading_embed = discord.Embed(
            title="âœ¨ Mass Pulling...",
            description=f"Pulling **{amount}** characters...",
            color=0x5865F2,
        )
        loading_embed.set_author(
            name=ctx.author.display_name,
            icon_url=ctx.author.display_avatar.url,
        )
        loading_embed.set_footer(text="This may take a moment...")
        msg = await ctx.send(embed=loading_embed)

        # Load data
        cards_dict = load(CARDS_FILE)
        rarities = load(RARITIES_FILE)
        bosses = load(BOSSES_FILE)

        if not cards_dict:
            embed = discord.Embed(
                title="âŒ No Cards Available",
                description="Card database is empty!",

            user["pulls"] -= amount

            for _ in range(amount):
            # Ticket chance (2.5%)
            if bosses and random.random() * 100 <= 2.5:
            total=sum(b.get("ticket_drop_rate", 0)
                           for b in bosses.values())
                if total > 0:
                                        r=random.uniform(0, total)
                            curr=0
                    for b in bosses.values():
                                                curr += b.get("ticket_drop_rate", 0)
                        if r <= curr:
                                                        tid=f"{b.get('name', '').lower().replace(' ', '_')}_ticket"
                            tickets_gained[tid]=tickets_gained.get(
                               tid, 0) + 1
                                user.setdefault("tickets", {})
                                user["tickets"][tid]=user["tickets"].get(
                                tid, 0) + 1
                                break

                                # Card pull
                                chosen=random.choices(
                                    cards_list, weights=weights, k=1)[0]
                                card_name=chosen.get("name", "Unknown")
                                rarity_key=chosen.get("rarity", "C")
                                rarity_info=rarities.get(rarity_key, {})
                                rarity_emoji=rarity_info.get("emoji", "â­")

                                user.setdefault("cards", [])
                                    user.setdefault("unlocked", [])
                                    user.setdefault("fragments", {})

                                    if card_name not in user.get("unlocked", []):
                # New unlock
                user.setdefault("unlocked", []).append(card_name)
                user["cards"].append(
                    {
                        "name": card_name,
                        "rarity": rarity_key,
                        "level": 1,
                        "exp": 0,
                        "evo": 0,
                        "aura": 0,
                    }
                )
                    count, _=new_counts.get(card_name, (0, rarity_emoji))
                    new_counts[card_name]=(count + 1, rarity_emoji)
                else:
                # Fragment (duplicate)
                user["fragments"][card_name]=user["fragments"].get(
                   card_name, 0) + 1
                    card_emoji=emojis.get(card_name) or "ğŸ§©"
                    count, _=shard_counts.get(card_name, (0, card_emoji))
                    shard_counts[card_name]=(count + 1, card_emoji)

                    # Save user data
                    users[uid]=user
                        save(USERS_FILE, users)

                        # Result embed
                        result_embed=discord.Embed(
            title="âœ¨ Mass Pull Complete!",
            description=f"Pulled **{amount}** characters!",
            color=0x2ECC71,
        )
            result_embed.set_author(
            name=ctx.author.display_name,
            icon_url=ctx.author.display_avatar.url,
        )

            # New cards section (rarity emoji)
            if new_counts:
        new_lines=[]
            for name, (count, rarity_emoji) in list(new_counts.items())[:15]:
        if count == 1:
        new_lines.append(f"{rarity_emoji} **{name}**")
                else:
        new_lines.append(f"{rarity_emoji} **{name}** Ã—`{count}`")
            if len(new_counts) > 15:
        new_lines.append(f"*...and {len(new_counts) - 15} more*")
            result_embed.add_field(
                name="ğŸ´ New Cards",
                value="\n".join(new_lines) or "None",
                inline=False,
            )

            # Fragment section (card emoji)
            if shard_counts:
            shard_lines=[]
            for name, (count, card_emoji) in list(shard_counts.items())[:15]:
            shard_lines.append(
                   f"{card_emoji or 'ğŸ§©'} **{name}** Ã—`{count}`")
                    if len(shard_counts) > 15:
                shard_lines.append(f"*...and {len(shard_counts) - 15} more*")
                        result_embed.add_field(
                name="ğŸ’ Fragments",
                value="\n".join(shard_lines) or "None",
                inline=False,
            )

            if tickets_gained:
            ticket_text="\n".join(
               [f"â€¢ **{tid}:** `{count}`" for tid,
                    count in tickets_gained.items()]
            )
                result_embed.add_field(
                name="ï¿½ğŸ« Tickets Gained",
                value=ticket_text,
                inline=False,
            )

            result_embed.add_field(
            name="ğŸƒ Remaining Pulls",
            value=f"`{user['pulls']}/12`",
            inline=True,
        )

            result_embed.set_footer(
                text="Thanks for supporting us on Patreon! ğŸ’œ")
            await msg.edit(embed=result_embed)

    @ commands.command(name="mr")
        async def mass_reset_and_pull(self, ctx):
        """Patreon-only: use one reset token to refill pulls, then mass pull all at once."""
        # Patreon check
        member=ctx.guild.get_member(
           ctx.author.id) if ctx.guild else ctx.author
            if not has_patreon_role(member):
            embed=discord.Embed(
                title="âŒ Patreon Only",
                description="This command is only available to **Patreon members**!\n\nSupport us on Patreon to unlock this feature!",
                color=0xE74C3C,
            )
                embed.set_author(
                name=ctx.author.display_name,
                icon_url=ctx.author.display_avatar.url,
            )
                return await ctx.send(embed=embed)

            # Load user and check reset tokens
            users=load(USERS_FILE)
            uid=str(ctx.author.id)
            user=self.ensure_user(users, uid)

            reset_tokens=user.get("reset_tokens", 0)
            if reset_tokens < 1:
            embed=discord.Embed(
                title="âŒ No Reset Tokens",
                description=(
                    "You don't have any reset tokens!\n\n"
                    "Ask an admin to give you reset tokens using `ls add reset <amount> @user`"
                ),
                color=0xE74C3C,
            )
                embed.set_author(
                name=ctx.author.display_name,
                icon_url=ctx.author.display_avatar.url,
            )
                return await ctx.send(embed=embed)

            # Refill pulls using one reset token
            user["pulls"]=config.MAX_PULLS
            user["reset_tokens"]=reset_tokens - 1
            user["last_pull_regen_ts"]=int(time.time())
            users[uid]=user
            save(USERS_FILE, users)

            # Now perform the same mass pull logic as mp
            amount=user.get("pulls", 0)
            if amount <= 0:
            max_pulls=user.get("max_pulls", config.MAX_PULLS)
            embed=discord.Embed(
                title="âŒ Out of Pulls!",
                description=(
                    f"You have `{user.get('pulls', 0)}/{max_pulls}` pulls left. "
                    "Nothing to mass pull.\n\nUse `ls cd` to check cooldowns."
                ),
                color=0xE74C3C,
            )
                embed.set_author(
                name=ctx.author.display_name,
                icon_url=ctx.author.display_avatar.url,
            )
                return await ctx.send(embed=embed)

            loading_embed=discord.Embed(
            title="âœ¨ Reset + Mass Pulling...",
            description=(
                f"Used 1 reset token to refill pulls to **{config.MAX_PULLS}/{config.MAX_PULLS}**.\n"
                f"Now pulling **{amount}** characters..."
            ),
            color=0x5865F2,
        )
            loading_embed.set_author(
            name=ctx.author.display_name,
            icon_url=ctx.author.display_avatar.url,
        )
            loading_embed.set_footer(text="This may take a moment...")
            msg=await ctx.send(embed=loading_embed)

            cards_dict=load(CARDS_FILE)
            rarities=load(RARITIES_FILE)
            bosses=load(BOSSES_FILE)

            if not cards_dict:
        embed=discord.Embed(
                title="âŒ No Cards Available",
                description="Card database is empty!",
                color=0xE74C3C,
            )
                await msg.edit(embed=embed)
                return

            cards_list=list(cards_dict.values())
            weights=[]
            for card in cards_list:
            rarity_key=card.get("rarity", "C")
            rarity_info=rarities.get(rarity_key, {})
            weight=rarity_info.get("weight_multiplier", 5)
            weights.append(weight)

            emojis=load(EMOJI_FILE) or {}

            new_counts={}
            shard_counts={}
            tickets_gained={}

            user["pulls"] -= amount

            for _ in range(amount):
            if bosses and random.random() * 100 <= 2.5:
            total=sum(b.get("ticket_drop_rate", 0)
                           for b in bosses.values())
                if total > 0:
                                        r=random.uniform(0, total)
                            curr=0
                    for b in bosses.values():
                                                curr += b.get("ticket_drop_rate", 0)
                        if r <= curr:
                                                        tid=f"{b.get('name', '').lower().replace(' ', '_')}_ticket"
                            tickets_gained[tid]=tickets_gained.get(
                               tid, 0) + 1
                                user.setdefault("tickets", {})
                                user["tickets"][tid]=user["tickets"].get(
                                tid, 0) + 1
                                break

                                chosen=random.choices(
                                    cards_list, weights=weights, k=1)[0]
                                card_name=chosen.get("name", "Unknown")
                                rarity_key=chosen.get("rarity", "C")
                                rarity_info=rarities.get(rarity_key, {})
                                rarity_emoji=rarity_info.get("emoji", "â­")

                                user.setdefault("cards", [])
                                    user.setdefault("unlocked", [])
                                    user.setdefault("fragments", {})

                                    if card_name not in user.get("unlocked", []):
                user.setdefault("unlocked", []).append(card_name)
                user["cards"].append(
                    {
                        "name": card_name,
                        "rarity": rarity_key,
                        "level": 1,
                        "exp": 0,
                        "evo": 0,
                        "aura": 0,
                    }
                )
                    count, _=new_counts.get(card_name, (0, rarity_emoji))
                    new_counts[card_name]=(count + 1, rarity_emoji)
                else:
                user["fragments"][card_name]=user["fragments"].get(
                   card_name, 0) + 1
                    card_emoji=emojis.get(card_name) or "ğŸ§©"
                    count, _=shard_counts.get(card_name, (0, card_emoji))
                    shard_counts[card_name]=(count + 1, card_emoji)

                    users[uid]=user
                        save(USERS_FILE, users)

                        result_embed=discord.Embed(
            title="âœ¨ Reset + Mass Pull Complete!",
            description=f"Pulled **{amount}** characters after resetting pulls!",
            color=0x2ECC71,
        )
            result_embed.set_author(
            name=ctx.author.display_name,
            icon_url=ctx.author.display_avatar.url,
        )

            if new_counts:
        new_lines=[]
            for name, (count, rarity_emoji) in list(new_counts.items())[:15]:
        if count == 1:
        new_lines.append(f"{rarity_emoji} **{name}**")
                else:
        new_lines.append(f"{rarity_emoji} **{name}** Ã—`{count}`")
            if len(new_counts) > 15:
        new_lines.append(f"*...and {len(new_counts) - 15} more*")
            result_embed.add_field(
                name="ğŸ´ New Cards",
                value="\n".join(new_lines) or "None",
                inline=False,
            )

            if shard_counts:
            shard_lines=[]
            for name, (count, card_emoji) in list(shard_counts.items())[:15]:
            shard_lines.append(
                   f"{card_emoji or 'ğŸ§©'} **{name}** Ã—`{count}`")
                    if len(shard_counts) > 15:
                shard_lines.append(f"*...and {len(shard_counts) - 15} more*")
                        result_embed.add_field(
                name="ğŸ’ Fragments",
                value="\n".join(shard_lines) or "None",
                inline=False,
            )

            if tickets_gained:
            ticket_text="\n".join(
               [f"â€¢ **{tid}:** `{count}`" for tid,
                    count in tickets_gained.items()]
            )
                result_embed.add_field(
                name="ğŸ« Tickets Gained",
                value=ticket_text,
                inline=False,
            )

            result_embed.add_field(
            name="ğŸƒ Remaining Pulls",
            value=f"`{user['pulls']}/12`",
            inline=True,
        )

            result_embed.set_footer(
                text="Thanks for supporting us on Patreon! ğŸ’œ")
            await msg.edit(embed=result_embed)


        def setup(bot):
        bot.add_cog(Gacha(bot))
